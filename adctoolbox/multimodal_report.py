"""
Multi-Modal Error Signatures Report Generator
多模态误差特征报告生成器

功能：生成6张独立的分析图
(a) Spectrum - 频谱图
(b) Time-domain error - 时域误差
(c) Phase-domain error - 相位域误差（极坐标）
(d) Code overflow - 码字溢出分布
(e) Error histogram by phase - 相位域误差直方图
(f) Error histogram by code - 码字域误差直方图

作者：ADC Toolbox
日期：2025-11-21
"""

import numpy as np
import matplotlib.pyplot as plt
import sys
import os

# 添加模块路径
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)


def plot_a_spectrum(data, fs=1e6, num_bits=12, fin=None, output_path='fig_a_spectrum.png'):
    """
    图(a): 频谱图 - Spectrum

    参数:
        data: ADC输出数据
        fs: 采样频率 (Hz)
        num_bits: ADC位数
        fin: 归一化输入频率 (None则自动检测)
        output_path: 输出路径
    """
    from ADC_Toolbox_Python.spec_plot import spec_plot
    from ADC_Toolbox_Python.sineFit import sine_fit
    from ADC_Toolbox_Python.findBin import find_bin

    data = np.asarray(data).flatten()
    N = len(data)

    # 自动检测频率 (使用sine_fit + find_bin，与run_all_tests.py一致)
    if fin is None or fin == 0:
        _, freq_est, _, _, _ = sine_fit(data)
        fin = find_bin(1, freq_est, N) / N

    # 调用spec_plot (参数与run_all_tests.py一致)
    # isPlot=1 generates the plot, then we save it
    ENoB, SNDR, SFDR, SNR, THD, pwr, NF, h = spec_plot(
        data, Fs=1.0, harmonic=0, label=1, OSR=1, isPlot=1
    )

    # Update title to match multimodal format
    plt.title('(a) Spectrum\nOutput Spectrum', fontsize=14, fontweight='bold', loc='left')

    # Save the figure generated by spec_plot
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"  [OK] Saved: {output_path}")

    return output_path


def plot_b_time_domain_error(data, fin, num_bits=12, output_path='fig_b_time_error.png'):
    """
    图(b): 时域误差 - Time-domain error

    参数:
        data: ADC输出数据
        fin: 归一化输入频率
        num_bits: ADC位数
        output_path: 输出路径
    """
    from ADC_Toolbox_Python.tomDecomp import tomDecomp

    data = np.asarray(data).flatten()
    N = len(data)

    # Thompson分解 (order=50，与run_all_tests.py一致)
    signal, error, indep, dep, phi = tomDecomp(data, fin, order=50, disp=0)

    # 计算显示范围 (显示~1.5个周期，与run_all_tests.py一致)
    xlim = min(max(int(1.5 / fin), 100), N)

    # 创建双Y轴图 (figsize=(12, 6)，与run_all_tests.py一致)
    fig, ax1 = plt.subplots(figsize=(12, 6))
    ax2 = ax1.twinx()

    # 左Y轴：信号
    ax1.plot(data[:xlim], 'kx', markersize=3, alpha=0.5, label='data')
    ax1.plot(signal[:xlim], '-', color='gray', linewidth=1.5, label='signal')
    ax1.set_xlim([0, xlim])
    ax1.set_ylabel('Signal', fontsize=12)
    ax1.tick_params(axis='y', labelcolor='k')

    # 右Y轴：误差
    ax2.plot(dep[:xlim], 'r-', label='dep', linewidth=1.5)
    ax2.plot(indep[:xlim], 'b-', label='indep', linewidth=1)
    ax2.set_ylabel('Error', fontsize=12)
    ax2.tick_params(axis='y', labelcolor='r')

    ax1.set_xlabel('Samples', fontsize=12)
    ax1.set_title('(b) Time-domain error', fontsize=14, fontweight='bold', loc='left')

    # 合并图例
    ax1.legend(loc='upper left', fontsize=10)
    ax2.legend(loc='upper right', fontsize=10)
    ax1.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"  [OK] Saved: {output_path}")

    return output_path


def plot_c_phase_domain_error(data, fin, num_bits=12, output_path='fig_c_phase_error.png'):
    """
    图(c): 相位域误差 - Phase-domain error (极坐标)

    参数:
        data: ADC输出数据
        fin: 归一化输入频率
        num_bits: ADC位数
        output_path: 输出路径
    """
    from ADC_Toolbox_Python.tomDecomp import tomDecomp

    data = np.asarray(data).flatten()
    N = len(data)

    # Thompson分解获取误差 (order=50，与run_all_tests.py一致)
    signal, error, indep, dep, phi = tomDecomp(data, fin, order=50, disp=0)

    # 计算相位
    t = np.arange(N)
    phase_rad = (phi + 2 * np.pi * fin * t) % (2 * np.pi)

    # 创建极坐标图 (log scale on radial axis for better error visualization)
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(projection='polar'))

    # Use absolute error for log scale
    error_abs = np.abs(error)
    # Filter out zeros to avoid log(0)
    error_abs_nonzero = error_abs[error_abs > 0]
    if len(error_abs_nonzero) > 0:
        error_min = np.min(error_abs_nonzero)
    else:
        error_min = 1e-10

    # Replace zeros with small value for plotting
    error_abs_plot = np.where(error_abs > 0, error_abs, error_min)

    # 绘制散点 (log scale)
    ax.scatter(phase_rad, error_abs_plot, c='blue', s=0.5, alpha=0.3)
    ax.set_title('(c) Phase-domain error\nSpectrum Phase (Log Scale)',
                fontsize=14, fontweight='bold', pad=20)
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(1)
    ax.set_yscale('log')  # Log scale on radial axis

    # Set radial limits
    if len(error_abs_nonzero) > 0:
        r_min = np.min(error_abs_nonzero) * 0.5
        r_max = np.max(error_abs) * 2
        ax.set_ylim([r_min, r_max])

    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"  [OK] Saved: {output_path}")

    return output_path


def plot_d_code_overflow(data, num_bits=12, output_path='fig_d_code_overflow.png'):
    """
    图(d): 码字溢出 - Code overflow

    参数:
        data: ADC输出数据
        num_bits: ADC位数
        output_path: 输出路径
    """
    data = np.asarray(data).flatten()
    N = len(data)

    # 归一化并转换为整数码字
    data_min = np.min(data)
    data_max = np.max(data)
    normalized = (data - data_min) / (data_max - data_min)
    codes = np.clip(normalized * (2**num_bits - 1), 0, 2**num_bits - 1).astype(int)

    # 计算每个bit的分布
    bit_distribution = np.zeros(num_bits)
    for bit_idx in range(num_bits):
        mask = (codes >> bit_idx) & 1
        bit_distribution[bit_idx] = np.sum(mask) / N * 100

    # 反转顺序（MSB在左）
    bit_labels = [f'{num_bits - 1 - i}' for i in range(num_bits)]
    x_pos = np.arange(num_bits)
    reversed_dist = bit_distribution[::-1]

    # 绘图
    fig, ax = plt.subplots(figsize=(10, 6))
    bars = ax.bar(x_pos, reversed_dist, color='royalblue', edgecolor='navy', linewidth=1.5)

    # 添加百分比标签
    for bar, pct in zip(bars, reversed_dist):
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height + 0.5,
               f'{pct:.1f}%', ha='center', va='bottom', fontsize=8)

    ax.set_xlabel('bit', fontsize=12)
    ax.set_ylabel('Relative Distribution', fontsize=12)
    ax.set_title('(d) Code overflow', fontsize=14, fontweight='bold', loc='left')
    ax.set_xticks(x_pos)
    ax.set_xticklabels(bit_labels)
    ax.set_ylim([0, 105])
    ax.grid(axis='y', alpha=0.3)

    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"  [OK] Saved: {output_path}")

    return output_path


def plot_e_error_hist_by_phase(data, fin, num_bits=12, output_path='fig_e_error_hist_phase.png'):
    """
    图(e): 相位域误差直方图 - Error histogram by phase

    参数:
        data: ADC输出数据
        fin: 归一化输入频率
        num_bits: ADC位数
        output_path: 输出路径
    """
    from ADC_Toolbox_Python.tomDecomp import tomDecomp
    from ADC_Toolbox_Python.errHistSine import errHistPhase

    data = np.asarray(data).flatten()
    N = len(data)

    # Thompson分解获取误差和相位 (order=50，与run_all_tests.py一致)
    signal, error, indep, dep, phi = tomDecomp(data, fin, order=50, disp=0)

    # 缩放数据并调用errHistPhase (与run_all_tests.py一致)
    # Note: errHistSine expects scaled data, use 2^12 as standard
    scaled = data * (2**12)
    emean_phase, erms_phase, phase_bins, _ = errHistPhase(
        scaled, bin_count=1000, fin=fin, disp=0
    )

    # 计算相位（度）
    t = np.arange(N)
    phi_list = (phi / np.pi * 180 + t * fin * 360) % 360

    # 创建图表（上下两部分）
    fig = plt.figure(figsize=(10, 8))

    # 上半部分：误差散点和均值
    ax1 = plt.subplot(2, 1, 1)
    ax1.plot(phi_list, error, 'r.', markersize=0.5, alpha=0.3, label='error')
    ax1.plot(phase_bins, emean_phase, 'b-', linewidth=2, label='mean')
    ax1.set_ylabel('error', fontsize=12)
    ax1.set_title('(e) Error histogram by phase', fontsize=14, fontweight='bold', loc='left')
    ax1.set_xlim([0, 360])
    ax1.legend(fontsize=10)
    ax1.grid(True, alpha=0.3)

    # 下半部分：RMS柱状图
    ax2 = plt.subplot(2, 1, 2)
    ax2.bar(phase_bins, erms_phase, width=1, color='skyblue', edgecolor='navy', linewidth=0.5)
    ax2.set_xlabel('phase(deg)', fontsize=12)
    ax2.set_ylabel('RMS error', fontsize=12)
    ax2.set_xlim([0, 360])
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"  [OK] Saved: {output_path}")

    return output_path


def plot_f_error_hist_by_code(data, fin, num_bits=12, output_path='fig_f_error_hist_code.png'):
    """
    图(f): 码字域误差直方图 - Error histogram by code

    参数:
        data: ADC输出数据
        fin: 归一化输入频率
        num_bits: ADC位数
        output_path: 输出路径
    """
    from ADC_Toolbox_Python.tomDecomp import tomDecomp
    from ADC_Toolbox_Python.errHistSine import errHistCode

    data = np.asarray(data).flatten()
    N = len(data)

    # Thompson分解获取误差 (order=50，与run_all_tests.py一致)
    signal, error, indep, dep, phi = tomDecomp(data, fin, order=50, disp=0)

    # 缩放数据并调用errHistCode (与run_all_tests.py一致)
    # Note: errHistSine expects scaled data, use 2^12 as standard
    scaled = data * (2**12)
    emean_code, erms_code, code_bins, _ = errHistCode(
        scaled, bin_count=1000, fin=fin, disp=0
    )

    # 创建图表（上下两部分）
    fig = plt.figure(figsize=(10, 8))

    # 上半部分：误差散点和均值
    ax1 = plt.subplot(2, 1, 1)
    ax1.plot(data, error, 'r.', markersize=0.5, alpha=0.3, label='error')
    ax1.plot(code_bins, emean_code, 'b-', linewidth=2, label='mean')
    ax1.set_ylabel('error', fontsize=12)
    ax1.set_title('(f) Error histogram by code', fontsize=14, fontweight='bold', loc='left')
    ax1.set_xlim([np.min(data), np.max(data)])
    ax1.legend(fontsize=10)
    ax1.grid(True, alpha=0.3)

    # 下半部分：RMS柱状图
    ax2 = plt.subplot(2, 1, 2)
    bin_width = (code_bins[1] - code_bins[0]) if len(code_bins) > 1 else 1
    ax2.bar(code_bins, erms_code, width=bin_width*0.8, color='skyblue', edgecolor='navy', linewidth=0.5)
    ax2.set_xlabel('code', fontsize=12)
    ax2.set_ylabel('RMS error', fontsize=12)
    ax2.set_xlim([np.min(data), np.max(data)])
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"  [OK] Saved: {output_path}")

    return output_path


def generate_multimodal_report(data, fs=1e6, num_bits=12, fin=None, output_dir='.'):
    """
    生成Multi-Modal Error Signatures报告（6张独立图片）

    参数:
        data: ADC输出数据 (1D numpy数组)
        fs: 采样频率 (Hz)
        num_bits: ADC位数
        fin: 归一化输入频率 f_in/f_sample (None则自动检测)
        output_dir: 输出目录

    返回:
        output_paths: 6张图片的路径列表
    """

    # 确保data是1D数组
    data = np.asarray(data).flatten()
    N = len(data)

    print(f"Generating Multi-Modal Error Signatures Report (6 individual figures)...")
    print(f"  Data points: {N}")
    print(f"  Sample rate: {fs/1e6:.2f} MHz")
    print(f"  ADC bits: {num_bits}")

    # 自动检测频率 (使用sine_fit + find_bin，与run_all_tests.py一致)
    if fin is None or fin == 0:
        try:
            from ADC_Toolbox_Python.sineFit import sine_fit
            from ADC_Toolbox_Python.findBin import find_bin
            _, freq_est, _, _, _ = sine_fit(data)
            fin = find_bin(1, freq_est, N) / N
            print(f"  Detected frequency: {fin:.10f}")
        except ImportError:
            spec = np.abs(np.fft.fft(data))
            spec[0] = 0
            bin_max = np.argmax(spec[:N//2])
            fin = bin_max / N
            print(f"  Estimated frequency: {fin:.10f}")

    # 确保输出目录存在
    os.makedirs(output_dir, exist_ok=True)

    # 生成6张图
    output_paths = []

    print("\n[1/6] Generating (a) Spectrum...")
    path_a = os.path.join(output_dir, 'fig_a_spectrum.png')
    plot_a_spectrum(data, fs, num_bits, fin, path_a)
    output_paths.append(path_a)

    print("\n[2/6] Generating (b) Time-domain error...")
    path_b = os.path.join(output_dir, 'fig_b_time_error.png')
    plot_b_time_domain_error(data, fin, num_bits, path_b)
    output_paths.append(path_b)

    print("\n[3/6] Generating (c) Phase-domain error...")
    path_c = os.path.join(output_dir, 'fig_c_phase_error.png')
    plot_c_phase_domain_error(data, fin, num_bits, path_c)
    output_paths.append(path_c)

    print("\n[4/6] Generating (d) Code overflow...")
    path_d = os.path.join(output_dir, 'fig_d_code_overflow.png')
    plot_d_code_overflow(data, num_bits, path_d)
    output_paths.append(path_d)

    print("\n[5/6] Generating (e) Error histogram by phase...")
    path_e = os.path.join(output_dir, 'fig_e_error_hist_phase.png')
    plot_e_error_hist_by_phase(data, fin, num_bits, path_e)
    output_paths.append(path_e)

    print("\n[6/6] Generating (f) Error histogram by code...")
    path_f = os.path.join(output_dir, 'fig_f_error_hist_code.png')
    plot_f_error_hist_by_code(data, fin, num_bits, path_f)
    output_paths.append(path_f)

    print(f"\n[OK] All 6 figures generated successfully!")
    print(f"Output directory: {output_dir}")

    return output_paths


if __name__ == "__main__":
    print("=" * 70)
    print("Multi-Modal Error Signatures Report Generator - 测试")
    print("=" * 70)

    # 生成测试数据
    N = 4096
    fs = 1e6
    fin_hz = 28320.3125
    re_fin = fin_hz / fs
    num_bits = 12

    t = np.arange(N) / fs

    # 理想信号
    signal_ideal = np.sin(2 * np.pi * fin_hz * t) * (2**(num_bits-1) - 100) + 2**(num_bits-1)

    # 添加3次谐波失真
    phase = (2 * np.pi * fin_hz * t) % (2 * np.pi)
    harmonic_3rd = 50 * np.sin(3 * phase)

    # 添加噪声
    noise = 10 * np.random.randn(N)

    # 合成ADC输出
    adc_output = signal_ideal + harmonic_3rd + noise
    adc_output = np.clip(adc_output, 0, 2**num_bits - 1)

    print(f"\n测试参数:")
    print(f"  采样点数: {N}")
    print(f"  采样频率: {fs/1e6:.2f} MHz")
    print(f"  输入频率: {fin_hz/1e3:.2f} kHz")
    print(f"  ADC位数: {num_bits}")

    # 生成报告
    output_dir = os.path.join(os.path.dirname(__file__), "..", "output_data", "test_multimodal")

    generate_multimodal_report(
        adc_output,
        fs=fs,
        num_bits=num_bits,
        fin=re_fin,
        output_dir=output_dir
    )

    print("\n[OK] Test completed!")
    print("=" * 70)

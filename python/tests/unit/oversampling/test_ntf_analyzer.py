"""Unit test for ntf_analyzer (Noise Transfer Function analyzer).

This test validates the ntf_analyzer function using noise-shaped signals.
It tests both lowpass and bandpass NTF configurations with various orders.
"""

import pytest
import numpy as np
import math
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend to avoid Tkinter issues
import matplotlib.pyplot as plt
from pathlib import Path
from scipy import signal
from adctoolbox.oversampling.ntf_analyzer import ntf_analyzer
from adctoolbox import analyze_spectrum, find_coherent_frequency
from adctoolbox.siggen.nonidealities import ADC_Signal_Generator


# Create output directory for test figures
output_dir = Path(__file__).parent / "test_output"
output_dir.mkdir(exist_ok=True)


def test_ntf_analyzer_lowpass_1st_order():
    """Test ntf_analyzer with 1st-order lowpass NTF.

    Validates against expected SNR improvement for ideal 1st-order
    delta-sigma modulator: NTF(z) = 1 - z^-1

    For 1st-order lowpass with OSR=16, theoretical SNR improvement
    should be approximately 31 dB (9 dB/octave improvement).
    """
    # Create 1st-order lowpass NTF: H(z) = 1 - z^-1
    num = [1, -1]
    den = [1, 0]
    ntf = signal.TransferFunction(num, den, dt=1)

    # Analyze performance with OSR = 16
    osr = 16
    flow = 0
    fhigh = 0.5 / osr

    snr = ntf_analyzer(ntf, flow, fhigh, is_plot=0)

    print(f"\n1st-order Lowpass NTF (OSR={osr}):")
    print(f"  Measured SNR improvement: {snr:.2f} dB")

    # For 1st-order, expect approximately 30-31 dB for OSR=16
    # (9 dB per doubling of OSR)
    assert 28 < snr < 33, \
        f"SNR out of expected range for 1st-order OSR=16: got {snr:.2f} dB, expected ~30-31 dB"


def test_ntf_analyzer_lowpass_2nd_order():
    """Test ntf_analyzer with 2nd-order lowpass NTF.

    Validates against expected SNR improvement for 2nd-order
    delta-sigma modulator: NTF(z) = (1 - z^-1)^2

    For 2nd-order, expect approximately 15 dB/octave improvement.
    """
    # Create 2nd-order lowpass NTF: H(z) = (1 - z^-1)^2
    num = [1, -2, 1]
    den = [1, 0, 0]
    ntf = signal.TransferFunction(num, den, dt=1)

    # Analyze performance with OSR = 16
    osr = 16
    flow = 0
    fhigh = 0.5 / osr

    snr = ntf_analyzer(ntf, flow, fhigh, is_plot=0)

    print(f"\n2nd-order Lowpass NTF (OSR={osr}):")
    print(f"  Measured SNR improvement: {snr:.2f} dB")

    # For 2nd-order with OSR=16, expect approximately 45-50 dB
    # (15 dB per doubling of OSR)
    assert 44 < snr < 50, \
        f"SNR out of expected range for 2nd-order OSR=16: got {snr:.2f} dB, expected ~45-50 dB"


def test_ntf_analyzer_bandpass():
    """Test ntf_analyzer with bandpass NTF.

    Validates bandpass NTF centered around normalized frequency 0.25.
    NTF(z) = 1 + z^-2 creates a notch at DC and Fs/2, peak at Fs/4.
    """
    # Create bandpass NTF: H(z) = 1 + z^-2
    num = [1, 0, 1]
    den = [1, 0, 0]
    ntf = signal.TransferFunction(num, den, dt=1)

    # Analyze performance around center frequency 0.25
    flow = 0.24
    fhigh = 0.26

    snr = ntf_analyzer(ntf, flow, fhigh, is_plot=0)

    print(f"\nBandpass NTF (fc=0.25, BW={fhigh-flow}):")
    print(f"  Measured SNR improvement: {snr:.2f} dB")

    # For bandpass, SNR should be positive (noise suppression in band)
    # The exact value depends on NTF shape, but should be > 0 dB
    assert snr > 0, f"Expected positive SNR improvement, got {snr:.2f} dB"


def test_ntf_analyzer_with_noise_shaped_signals():
    """Test ntf_analyzer using actual noise-shaped signals generated by ADC_Signal_Generator.

    This test:
    1. Generates noise-shaped signals using different NTF orders (1-4)
    2. Analyzes their spectrum to measure actual SNR
    3. Uses ntf_analyzer to predict theoretical SNR improvement
    4. Compares measured vs predicted performance
    """
    # Signal parameters
    N = 2**13
    Fs = 100e6
    OSR = 32
    Fin_target = Fs / (2 * OSR) / 14
    A = 0.4
    DC = 0.0

    # Quantization parameters
    n_bits = 10
    quant_range = (-0.5, 0.5)
    thermal_noise_rms = 100e-6

    # Find coherent frequency
    Fin, Fin_bin = find_coherent_frequency(fs=Fs, fin_target=Fin_target, n_fft=N)

    # Initialize signal generator
    gen = ADC_Signal_Generator(N=N, Fs=Fs, Fin=Fin, A=A, DC=DC)

    # Test different noise shaping orders
    orders = [1, 2, 3, 4]
    N_runs = 16

    results = {}

    for order in orders:
        # Generate noise-shaped signals
        signal_matrix = np.zeros((N_runs, N))

        for run in range(N_runs):
            sig = gen.apply_thermal_noise(noise_rms=thermal_noise_rms)
            sig = gen.apply_noise_shaping(sig, n_bits=n_bits, quant_range=quant_range, order=order)
            signal_matrix[run, :] = sig

        # Analyze spectrum to measure actual SNR
        spec_result = analyze_spectrum(signal_matrix, fs=Fs, osr=OSR)
        measured_snr = spec_result['snr_dbc']

        # Create theoretical NTF: H(z) = (1 - z^-1)^order
        ntf_num = np.zeros(order + 1)
        for k in range(order + 1):
            ntf_num[k] = (-1)**k * math.comb(order, k)
        ntf_den = np.zeros(order + 1)
        ntf_den[0] = 1

        ntf = signal.TransferFunction(ntf_num, ntf_den, dt=1)

        # Predict SNR improvement using ntf_analyzer
        flow = 0
        fhigh = 0.5 / OSR
        predicted_snr_improvement = ntf_analyzer(ntf, flow, fhigh, is_plot=0)

        # Store results
        results[order] = {
            'measured_snr': measured_snr,
            'predicted_improvement': predicted_snr_improvement,
        }

        print(f"\nOrder {order} Noise Shaping (OSR={OSR}, {n_bits}-bit):")
        print(f"  Measured SNR: {measured_snr:.2f} dB")
        print(f"  Predicted NTF improvement: {predicted_snr_improvement:.2f} dB")

    # Create comparison plot
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Plot 1: Measured SNR vs Order
    orders_list = list(results.keys())
    measured_snrs = [results[o]['measured_snr'] for o in orders_list]
    predicted_improvements = [results[o]['predicted_improvement'] for o in orders_list]

    ax1.plot(orders_list, measured_snrs, 'o-', linewidth=2, markersize=8, label='Measured SNR')
    ax1.set_xlabel('Noise Shaping Order', fontsize=12)
    ax1.set_ylabel('SNR (dB)', fontsize=12)
    ax1.set_title(f'Measured SNR vs Noise Shaping Order\n(OSR={OSR}, {n_bits}-bit)',
                  fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # Plot 2: Predicted NTF improvement vs Order
    ax2.plot(orders_list, predicted_improvements, 's-', linewidth=2, markersize=8,
             color='orange', label='Predicted NTF Improvement')
    ax2.set_xlabel('Noise Shaping Order', fontsize=12)
    ax2.set_ylabel('SNR Improvement (dB)', fontsize=12)
    ax2.set_title('NTF Analyzer Predicted Improvement\nvs Noise Shaping Order',
                  fontsize=12, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    plt.tight_layout()
    fig_path = output_dir / 'test_ntf_analyzer_with_noise_shaped_signals.png'
    plt.savefig(fig_path, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"\n[Figure saved] -> {fig_path}")

    # Verify that predicted NTF improvements increase with order
    # Note: Measured SNR may hit quantization limit for high orders
    for i in range(len(orders_list) - 1):
        assert results[orders_list[i+1]]['predicted_improvement'] > results[orders_list[i]]['predicted_improvement'], \
            f"Order {orders_list[i+1]} should have higher predicted improvement than Order {orders_list[i]}"


def test_ntf_analyzer_tuple_input():
    """Test ntf_analyzer with tuple (num, den) input instead of TransferFunction."""
    # Create 1st-order lowpass NTF as tuple
    num = [1, -1]
    den = [1, 0]
    ntf = (num, den)

    # Analyze performance
    osr = 16
    flow = 0
    fhigh = 0.5 / osr

    snr = ntf_analyzer(ntf, flow, fhigh, is_plot=0)

    print(f"\nTuple input test (1st-order, OSR={osr}):")
    print(f"  SNR improvement: {snr:.2f} dB")

    # Should get similar result as test_ntf_analyzer_lowpass_1st_order
    assert 28 < snr < 33, \
        f"SNR out of expected range with tuple input: got {snr:.2f} dB"


def test_ntf_analyzer_plotting():
    """Test ntf_analyzer plotting functionality (visual verification)."""
    # Create 2nd-order lowpass NTF
    num = [1, -2, 1]
    den = [1, 0, 0]
    ntf = signal.TransferFunction(num, den, dt=1)

    # Test with plotting enabled
    osr = 16
    flow = 0
    fhigh = 0.5 / osr

    # Redirect plot to file instead of showing
    plt.figure(figsize=(10, 6))
    snr = ntf_analyzer(ntf, flow, fhigh, is_plot=1)

    fig_path = output_dir / 'test_ntf_analyzer_plot_lowpass.png'
    plt.savefig(fig_path, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"\n[Lowpass plot saved] -> {fig_path}")

    # Test bandpass plotting
    num_bp = [1, 0, 1]
    den_bp = [1, 0, 0]
    ntf_bp = signal.TransferFunction(num_bp, den_bp, dt=1)

    plt.figure(figsize=(10, 6))
    snr_bp = ntf_analyzer(ntf_bp, 0.24, 0.26, is_plot=1)

    fig_path_bp = output_dir / 'test_ntf_analyzer_plot_bandpass.png'
    plt.savefig(fig_path_bp, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"[Bandpass plot saved] -> {fig_path_bp}")

    # Verify figures were created
    assert fig_path.exists() and fig_path.stat().st_size > 0
    assert fig_path_bp.exists() and fig_path_bp.stat().st_size > 0


if __name__ == "__main__":
    # Run tests individually for debugging
    test_ntf_analyzer_lowpass_1st_order()
    test_ntf_analyzer_lowpass_2nd_order()
    test_ntf_analyzer_bandpass()
    test_ntf_analyzer_tuple_input()
    test_ntf_analyzer_with_noise_shaped_signals()
    test_ntf_analyzer_plotting()
    print("\nAll tests passed!")
